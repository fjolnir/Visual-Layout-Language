%{
    @import Foundation;
    @import ObjectiveC.runtime;
    #include <stdlib.h>
    #import "NSString+VLLExtensions.h"
    #import "NSInvocation+VLLExtensions.h"
    #import "NSLayoutConstraint+VLLExtensions.h"

    #define YYSTYPE id
    #define YY_CTX_LOCAL
//  #define YY_DEBUG

    // General purpose stack
    #define StackTop [yy->stack lastObject]
    #define StackPeek(ofs) yy->stack[[yy->stack count] + (ofs) - 1]
    #define PushStack(obj...) [yy->stack addObject:(obj)]
    #define PopStack() ({ id const top = StackTop; [yy->stack removeLastObject]; top; })
    
    // Orientation stack
    #define Orientation [yy->orientationStack lastObject]
    #define PushOrientation() [yy->orientationStack addObject:[yy->orientationStack lastObject]]
    #define SetOrientation(orien...) yy->orientationStack[[yy->orientationStack count]-1] = orien
    #define PopOrientation() ({ id const top = Orientation; [yy->orientationStack removeLastObject]; top; })
    
    // View stack
    #define CurrView ((VLLView *)[yy->viewStack lastObject])
    #define LastView yy->viewStack[[yy->viewStack count] - 2]
    #define PushView(obj...) [yy->viewStack addObject:(obj)]
    #define PopView() ({ VLLView * const top = CurrView; [yy->viewStack removeLastObject]; top; })
    
    #define VLLAxisToDimension(axis) (axis) == VLLLayoutConstraintAxisHorizontal ? NSLayoutAttributeWidth \
                                                                                 : NSLayoutAttributeHeight
    #define VLLAxisToLeadingEdge(axis) (axis) == VLLLayoutConstraintAxisHorizontal ? NSLayoutAttributeLeading \
                                                                                   : NSLayoutAttributeTop
    #define VLLAxisToTrailingEdge(axis) (axis) == VLLLayoutConstraintAxisHorizontal ? NSLayoutAttributeTrailing \
                                                                                    : NSLayoutAttributeBottom
    
    #define SyntaxError(...) do { \
        int line = 1; \
        for(int i = 0; i < yy->__pos; ++i) { \
            if(yy->__buf[i] == '\n') ++line; \
        } \
        NSString *msg = [NSString stringWithFormat:__VA_ARGS__]; \
        [NSException raise:@"Syntax error" format:@"Line %d: Syntax error! %@", line, (msg)]; \
    } while(0)
%}

Layout   = - Rule+ EOF ~{ SyntaxError(@""); }

Rule     = { PushStack([NSMutableDictionary dictionary]); PushOrientation(); }
           Axis?
           (PIPE c:Conn { StackTop[@"leadingConstraints"] = c; })?
           View {
               PushView($$);
               if(StackTop[@"leadingConstraints"]) {
                   for(NSDictionary *pred in StackTop[@"leadingConstraints"]) {
                        [NSLayoutConstraint vll_addLeadingEdgeConstraintsForAxis:[pred[@"orientation"] integerValue]
                                                                            view:CurrView
                                                                       superview:LastView
                                                                       relatedBy:[pred[@"relation"] integerValue]
                                                                      multiplier:1
                                                                        constant:[pred[@"object"] doubleValue]
                                                                        priority:[pred[@"priority"] floatValue]];
                   }
               }
           }
           (c:Conn connectedView:View {
               VLLView * const previousView = PopView();
               PushView(connectedView);
               
               for(NSDictionary *pred in c) {
                    [NSLayoutConstraint vll_addSpacingConstraintsForAxis:[pred[@"orientation"] integerValue]
                                                               firstView:CurrView
                                                              secondView:previousView
                                                               relatedBy:[pred[@"relation"] integerValue]
                                                              multiplier:1
                                                                constant:[pred[@"object"] doubleValue]
                                                                priority:[pred[@"priority"] floatValue]];
               }
           })*
           (c:Conn PIPE {
               for(NSDictionary *pred in c) {
                    [NSLayoutConstraint vll_addTrailingEdgeConstraintsForAxis:[pred[@"orientation"] integerValue]
                                                                         view:CurrView
                                                                    superview:LastView
                                                                    relatedBy:[pred[@"relation"] integerValue]
                                                                   multiplier:1
                                                                     constant:[pred[@"object"] doubleValue]
                                                                     priority:[pred[@"priority"] floatValue]];
               }
           })?
           { $$ = PopStack(); PopView(); PopOrientation(); }


## Views
View     = ViewDef | ViewRef

ViewDef  = LBRACKET
               klass:CONST ident:ViewIdent {
                   VLLView * const view = [NSClassFromString(klass) new];
                   view.translatesAutoresizingMaskIntoConstraints = NO;
                   if(!CurrView || CurrView == yy->container)
                       [yy->rootViews addObject:view];
                   [CurrView addSubview:view];
                   PushView(view);
                   PushStack(view);
                   if(ident) yy->views[ident] = view;
               }
               (preds:PredicateList {
                   for(NSDictionary *pred in preds) {
                       [NSLayoutConstraint vll_addSizeConstraintsForAxis:[pred[@"orientation"] integerValue]
                                                                  onView:CurrView
                                                        toViewOrConstant:pred[@"object"]
                                                               relatedBy:[pred[@"relation"] integerValue]
                                                              multiplier:1
                                                                priority:[pred[@"priority"] integerValue]];
                   }
               })?
               Messages?
           RBRACKET
           (LBRACE
               rule:Rule*
            RBRACE ~{ SyntaxError(@"Unterminated curly brace"); })? { $$ = PopView(); PopStack(); }

ViewIdent =                   { $$ = nil; }
            (HASH ident:IDENT { $$ = ident; })?

ViewRef = LBRACKET ident:IDENT { PushStack(yy->views[ident]); }
          (preds:PredicateList {
              for(NSDictionary *pred in preds) {
                  [NSLayoutConstraint vll_addSizeConstraintsForAxis:[pred[@"orientation"] integerValue]
                                                             onView:StackTop
                                                   toViewOrConstant:pred[@"object"]
                                                          relatedBy:[pred[@"relation"] integerValue]
                                                         multiplier:1
                                                           priority:[pred[@"priority"] integerValue]];
              }
          })? RBRACKET { $$ = PopStack(); }


## Message passing
Messages = Message (SEMICOLON Message)*
Message  = { PushStack(@{  @"selector": [NSMutableString string],
                          @"arguments": [NSMutableArray array] }); }
           (name:SelPart COLON arg:Literal {
             [StackTop[@"selector"] appendFormat:@"%@:", name];
             [StackTop[@"arguments"] addObject:arg];
            }
            | name:SelPart ASGN arg:Literal {
                [StackTop[@"selector"] appendFormat:@"set%@:", [name vll_capitalizedString]];
                [StackTop[@"arguments"] addObject:arg];
            })+ {
                $$ = PopStack();
                $$ = [yy->parserObj _sendMessageTo:StackTop
                                          selector:NSSelectorFromString($$[@"selector"])
                                         arguments:$$[@"arguments"]];
            }
SelPart  = IDENT|CONST


## Connections / Predicates
Conn     = DASH preds:PredicateList DASH { $$ = preds; }
         | DASH { $$ = @[@{ @"object": @20, @"relation": @(NSLayoutRelationEqual), @"orientation": Orientation }]; }

PredicateList = obj:ObjOfPred { $$ = @[@{ @"object": obj,
                                          @"relation": @(NSLayoutRelationEqual),
                                          @"orientation": Orientation }]; }
              | LPAREN { PushOrientation(); }
                    pred:Predicate { PushStack([NSMutableArray arrayWithObject:pred]); }
                    (COMMA pred:Predicate { [StackTop addObject:pred]; })*
                RPAREN {
                    PopOrientation();
                    $$ = PopStack();
                }
Predicate = Axis?
                rel:Relation ~{ SyntaxError(@"Expected ==/>=/<="); }
                obj:ObjOfPred
                prio:Priority {
    $$ = @{ @"relation": rel,
            @"object": obj,
            @"priority": prio,
            @"orientation": Orientation };
}

Priority = { $$ = @0 } (AT p:NUMBER ~{ SyntaxError(@"Incomplete priority"); }
                                     { $$ = p; })?
ObjOfPred = number:NUMBER { $$ = number; }
| name:IDENT    { $$ = yy->views[name]; if(!$$) SyntaxError(@"View %@ doesn't exist", name); }


Axis     = 'V' COLON ~{ SyntaxError(@"Expected colon"); }
                      { $$ = @(VLLLayoutConstraintAxisVertical);   SetOrientation($$); }
         | 'H' COLON ~{ SyntaxError(@"Expected colon"); }
                      { $$ = @(VLLLayoutConstraintAxisHorizontal); SetOrientation($$); }
         | 'X' COLON ~{ SyntaxError(@"Expected colon"); }
                      { $$ = @(VLLLayoutConstraintAxisHorizontal | VLLLayoutConstraintAxisVertical);
                        SetOrientation($$); }


Relation  = LEQ { $$ = @(NSLayoutRelationLessThanOrEqual); }
          | GEQ { $$ = @(NSLayoutRelationGreaterThanOrEqual); }
          | EQ? { $$ = @(NSLayoutRelationEqual); }


## Literals
Literal   = NUMBER|STRING|Function|Object

Function  = '$' name:CONST LPAREN {
                PushStack([NSMutableArray array]); 
                PushStack([name lowercaseString]); 
            }
            (arg:Literal        { [StackPeek(-1) addObject:arg]; }
             (COMMA arg:Literal { [StackPeek(-1) addObject:arg]; })*)?
            RPAREN {
    $$ = [yy->parserObj _resolveFunction:PopStack() withParameters:PopStack()];
}
Object    = '$[' klass:CONST { PushStack(NSClassFromString(klass)); }
                 m:Message ']' { $$ = m; PopStack(); }


## Tokens
IDENT     = <[a-z] [a-zA-Z_0-9]*> -   { $$ = @(yytext); }
CONST     = <[A-Z] [a-zA-Z_0-9]*> -   { $$ = @(yytext); }
STRING    = '"' < (!'"' .)* > '"' -   { $$ = @(yytext); }
NUMBER    = <[0-9]+ ('.' [0-9]+)* > - { $$ = @(strtod(yytext, NULL)); }

LEQ       = '<=' -
GEQ       = '>=' -
EQ        = '==' -
ASGN      = '='  -
COLON     = ':'  -
SEMICOLON = ';'  -
COMMA     = ','  -
HASH      = '#'  -
LBRACE    = '{'  -
RBRACE    = '}'  -
LBRACKET  = '['  -
RBRACKET  = ']'  -
LPAREN    = '('  -
RPAREN    = ')'  -
DASH      = '-'  -
PIPE      = '|'  -
AT        = '@'  -
-         = ( SPACE | COMMENT )*
SPACE     = ' ' | '\t' | EOL
COMMENT   = '\\' ( !EOL . )* EOL
EOL       = '\r\n' | '\n' | '\r'
EOF       = !.
