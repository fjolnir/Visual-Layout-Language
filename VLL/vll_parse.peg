%{
    @import Foundation;
    @import ObjectiveC.runtime;
    #include <stdlib.h>
    #import "NSString+VLLExtensions.h"
    #import "NSInvocation+VLLExtensions.h"

    #define YYSTYPE id
    #define YY_CTX_LOCAL
//  #define YY_DEBUG

    // General purpose stack
    #define StackTop [yy->stack lastObject]
    #define StackPeek(ofs) yy->stack[[yy->stack count] + (ofs) - 1]
    #define PushStack(obj...) [yy->stack addObject:(obj)]
    #define PopStack() ({ id const top = StackTop; [yy->stack removeLastObject]; top; })
    
    // Orientation stack
    #define Orientation [yy->orientationStack lastObject]
    #define PushOrientation() [yy->orientationStack addObject:[yy->orientationStack lastObject]]
    #define SetOrientation(orien...) yy->orientationStack[[yy->orientationStack count]-1] = orien
    #define PopOrientation() ({ id const top = Orientation; [yy->orientationStack removeLastObject]; top; })
    
    // View stack
    #define CurrView ((VLLView *)[yy->viewStack lastObject])
    #define LastView yy->viewStack[[yy->viewStack count] - 2]
    #define PushView(obj...) [yy->viewStack addObject:(obj)]
    #define PopView() ({ VLLView * const top = CurrView; [yy->viewStack removeLastObject]; top; })
    
    #define VLLAxisToDimension(axis) (axis) == VLLLayoutConstraintAxisHorizontal ? NSLayoutAttributeWidth \
                                                                                 : NSLayoutAttributeHeight
    #define VLLAxisToLeadingEdge(axis) (axis) == VLLLayoutConstraintAxisHorizontal ? NSLayoutAttributeLeading \
                                                                                   : NSLayoutAttributeTop
    #define VLLAxisToTrailingEdge(axis) (axis) == VLLLayoutConstraintAxisHorizontal ? NSLayoutAttributeTrailing \
                                                                                    : NSLayoutAttributeBottom
%}

Layout   = Rule+ EOF

Rule     = { PushStack([NSMutableDictionary dictionary]); PushOrientation(); }
           Axis?
           (PIPE c:Conn { StackTop[@"leadingConstraints"] = c; })?
           view:View {
               PushView(view);
               if(StackTop[@"leadingConstraints"]) {
                   for(NSDictionary *pred in StackTop[@"leadingConstraints"]) {
                       NSLayoutConstraint * const constr = [NSLayoutConstraint
                                                            constraintWithItem:CurrView
                                                            attribute:VLLAxisToLeadingEdge([pred[@"orientation"] integerValue])
                                                            relatedBy:[pred[@"relation"] integerValue]
                                                            toItem:LastView
                                                            attribute:VLLAxisToLeadingEdge([pred[@"orientation"] integerValue])
                                                            multiplier:1
                                                            constant:[pred[@"object"] doubleValue]];
                       if([pred[@"priority"] floatValue] > 0)
                           constr.priority = [pred[@"priority"] floatValue];
                       [LastView addConstraint:constr];
                   }
               }
           }
           (c:Conn connectedView:View {
               VLLView * const previousView = PopView();
               PushView(connectedView);
               
               for(NSDictionary *pred in c) {
                   NSLayoutConstraint * const constr = [NSLayoutConstraint
                                                        constraintWithItem:CurrView
                                                        attribute:VLLAxisToLeadingEdge([pred[@"orientation"] integerValue])
                                                        relatedBy:[pred[@"relation"] integerValue]
                                                        toItem:previousView
                                                        attribute:VLLAxisToTrailingEdge([pred[@"orientation"] integerValue])
                                                        multiplier:1
                                                        constant:[pred[@"object"] doubleValue]];
                   if([pred[@"priority"] floatValue] > 0)
                       constr.priority = [pred[@"priority"] floatValue];
                   [LastView addConstraint:constr];
               }
           })*
           (c:Conn PIPE {
               for(NSDictionary *pred in c) {
                   NSLayoutConstraint * const constr = [NSLayoutConstraint
                                                        constraintWithItem:LastView
                                                        attribute:VLLAxisToTrailingEdge([pred[@"orientation"] integerValue])
                                                        relatedBy:[pred[@"relation"] integerValue]
                                                        toItem:CurrView
                                                        attribute:VLLAxisToTrailingEdge([pred[@"orientation"] integerValue])
                                                        multiplier:1
                                                        constant:[pred[@"object"] doubleValue]];
                   if([pred[@"priority"] floatValue] > 0)
                       constr.priority = [pred[@"priority"] floatValue];
                   [LastView addConstraint:constr];
               }
           })?
           { $$ = PopStack(); PopView(); PopOrientation(); }


## Views
View     = ViewDef | ViewRef

ViewDef  = LBRACKET
               klass:CONST ident:ViewIdent {
                   VLLView * const view = [NSClassFromString(klass) new];
                   view.translatesAutoresizingMaskIntoConstraints = NO;
                   if(!CurrView || CurrView == yy->container)
                       [yy->rootViews addObject:view];
                   [CurrView addSubview:view];
                   PushView(view);
                   PushStack(view);
                   if(ident) yy->views[ident] = view;
               }
               (preds:PredicateList {
                   for(NSDictionary *pred in preds) {
                       NSLayoutConstraint * const constr = [NSLayoutConstraint
                                                            constraintWithItem:CurrView
                                                            attribute:VLLAxisToDimension([pred[@"orientation"] integerValue])
                                                            relatedBy:[pred[@"relation"] integerValue]
                                                            toItem:nil
                                                            attribute:NSLayoutAttributeNotAnAttribute
                                                            multiplier:1
                                                            constant:[pred[@"object"] doubleValue]];
                       if([pred[@"priority"] floatValue] > 0)
                           constr.priority = [pred[@"priority"] floatValue];
                       [LastView addConstraint:constr];
                   }
               })?
               Messages?
           RBRACKET
           (LBRACE
               rule:Rule*
            RBRACE)? { $$ = PopView(); PopStack(); }

ViewIdent =                   { $$ = nil; }
            (HASH ident:IDENT { $$ = ident; })?

ViewRef = LBRACKET ident:IDENT { PushStack(yy->views[ident]); }
          (preds:PredicateList {
              for(NSDictionary *pred in preds) {
                  NSLayoutConstraint * const constr = [NSLayoutConstraint
                                                       constraintWithItem:StackTop
                                                       attribute:VLLAxisToDimension([pred[@"orientation"] integerValue])
                                                       relatedBy:[pred[@"relation"] integerValue]
                                                       toItem:nil
                                                       attribute:NSLayoutAttributeNotAnAttribute
                                                       multiplier:1
                                                       constant:[pred[@"object"] doubleValue]];
                  if([pred[@"priority"] floatValue] > 0)
                      constr.priority = [pred[@"priority"] floatValue];
                  [LastView addConstraint:constr];
              }
          })? RBRACKET { $$ = PopStack(); }


## Message passing
Messages = Message (SEMICOLON Message)*
Message  = { PushStack(@{  @"selector": [NSMutableString string],
                          @"arguments": [NSMutableArray array] }); }
           (name:SelPart COLON arg:Literal {
             [StackTop[@"selector"] appendFormat:@"%@:", name];
             [StackTop[@"arguments"] addObject:arg];
            }
            | name:SelPart ASGN arg:Literal {
                [StackTop[@"selector"] appendFormat:@"set%@:", [name vll_capitalizedString]];
                [StackTop[@"arguments"] addObject:arg];
            })+ {
                $$ = PopStack();
                $$ = [yy->parserObj _sendMessageTo:StackTop
                                          selector:NSSelectorFromString($$[@"selector"])
                                         arguments:$$[@"arguments"]];
            }
SelPart  = IDENT|CONST


## Connections / Predicates
Conn     = DASH preds:PredicateList DASH { $$ = preds; }
         | DASH { $$ = @[@{ @"object": @20, @"relation": @(NSLayoutRelationEqual), @"orientation": Orientation }]; }

PredicateList = obj:ObjOfPred { $$ = @[@{ @"object": yy->views[obj] ?: obj,
                                          @"relation": @(NSLayoutRelationEqual),
                                          @"orientation": Orientation }]; }
              | LPAREN { PushOrientation(); }
                    pred:Predicate { PushStack([NSMutableArray arrayWithObject:pred]); }
                    (COMMA pred:Predicate { [StackTop addObject:pred]; })*
                RPAREN {
                    PopOrientation();
                    $$ = PopStack();
                }
Predicate = Axis? rel:Relation obj:ObjOfPred prio:Priority {
    $$ = @{ @"relation": rel,
            @"object": yy->views[obj] ?: obj,
            @"priority": prio,
            @"orientation": Orientation };
}

Priority = { $$ = @50 } (AT p:NUMBER { $$ = p; })?
ObjOfPred = NUMBER|IDENT


Axis     = 'V' COLON { $$ = @(VLLLayoutConstraintAxisVertical);   SetOrientation($$); }
         | 'H' COLON { $$ = @(VLLLayoutConstraintAxisHorizontal); SetOrientation($$); }


Relation  = LEQ { $$ = @(NSLayoutRelationLessThanOrEqual); }
          | GEQ { $$ = @(NSLayoutRelationGreaterThanOrEqual); }
          | EQ? { $$ = @(NSLayoutRelationEqual); }


## Literals
Literal   = NUMBER|STRING|Function|Object

Function  = '$' name:CONST LPAREN {
                PushStack([NSMutableArray array]); 
                PushStack([name lowercaseString]); 
            }
            (arg:Literal        { [StackPeek(-1) addObject:arg]; }
             (COMMA arg:Literal { [StackPeek(-1) addObject:arg]; })*)?
            RPAREN {
    $$ = [yy->parserObj _resolveFunction:PopStack() withParameters:PopStack()];
}
Object    = '$[' klass:CONST { PushStack(NSClassFromString(klass)); }
                 m:Message ']' { $$ = m; PopStack(); }


## Tokens
IDENT     = <[a-z] [a-zA-Z_0-9]*> -   { $$ = @(yytext); }
CONST     = <[A-Z] [a-zA-Z_0-9]*> -   { $$ = @(yytext); }
STRING    = '"' < (!'"' .)* > '"' -   { $$ = @(yytext); }
NUMBER    = <[0-9]+ ('.' [0-9]+)* > - { $$ = @(strtod(yytext, NULL)); }

LEQ       = '<=' -
GEQ       = '>=' -
EQ        = '==' -
ASGN      = '='  -
COLON     = ':'  -
SEMICOLON = ';'  -
COMMA     = ','  -
HASH      = '#'  -
LBRACE    = '{'  -
RBRACE    = '}'  -
LBRACKET  = '['  -
RBRACKET  = ']'  -
LPAREN    = '('  -
RPAREN    = ')'  -
DASH      = '-'  -
PIPE      = '|'  -
AT        = '@'  -
-         = ( SPACE | COMMENT )*
SPACE     = ' ' | '\t' | EOL
COMMENT   = '\\' ( !EOL . )* EOL
EOL       = '\r\n' | '\n' | '\r'
EOF       = !.
